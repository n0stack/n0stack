// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/kvm/kvm.proto

/*
Package kvm is a generated protocol buffer package.

It is generated from these files:
	proto/kvm/kvm.proto

It has these top-level messages:
	KVM
	ApplyKVMRequest
	DeleteKVMRequest
	ActionKVMRequest
*/
package kvm

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/empty"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type KVM_RunLevel int32

const (
	KVM_SHUTDOWN KVM_RunLevel = 0
	KVM_RUNNING  KVM_RunLevel = 1
	KVM_PAUSED   KVM_RunLevel = 2
)

var KVM_RunLevel_name = map[int32]string{
	0: "SHUTDOWN",
	1: "RUNNING",
	2: "PAUSED",
}
var KVM_RunLevel_value = map[string]int32{
	"SHUTDOWN": 0,
	"RUNNING":  1,
	"PAUSED":   2,
}

func (x KVM_RunLevel) String() string {
	return proto.EnumName(KVM_RunLevel_name, int32(x))
}
func (KVM_RunLevel) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

type KVM struct {
	Uuid string `protobuf:"bytes,1,opt,name=uuid" json:"uuid,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// CPU
	CpuCores uint32 `protobuf:"varint,3,opt,name=cpu_cores,json=cpuCores" json:"cpu_cores,omitempty"`
	// Memory
	MemoryBytes uint64                  `protobuf:"varint,4,opt,name=memory_bytes,json=memoryBytes" json:"memory_bytes,omitempty"`
	Volumes     map[string]*KVM_Storage `protobuf:"bytes,5,rep,name=volumes" json:"volumes,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Nics        map[string]*KVM_NIC     `protobuf:"bytes,6,rep,name=nics" json:"nics,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	RunLevel    KVM_RunLevel            `protobuf:"varint,7,opt,name=run_level,json=runLevel,enum=n0stack.n0core.kvm.KVM_RunLevel" json:"run_level,omitempty"`
	// TCP port of websocket vnc which is opened by qemu
	VncPort int32  `protobuf:"varint,8,opt,name=vnc_port,json=vncPort" json:"vnc_port,omitempty"`
	QmpPath string `protobuf:"bytes,9,opt,name=qmp_path,json=qmpPath" json:"qmp_path,omitempty"`
}

func (m *KVM) Reset()                    { *m = KVM{} }
func (m *KVM) String() string            { return proto.CompactTextString(m) }
func (*KVM) ProtoMessage()               {}
func (*KVM) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *KVM) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *KVM) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *KVM) GetCpuCores() uint32 {
	if m != nil {
		return m.CpuCores
	}
	return 0
}

func (m *KVM) GetMemoryBytes() uint64 {
	if m != nil {
		return m.MemoryBytes
	}
	return 0
}

func (m *KVM) GetVolumes() map[string]*KVM_Storage {
	if m != nil {
		return m.Volumes
	}
	return nil
}

func (m *KVM) GetNics() map[string]*KVM_NIC {
	if m != nil {
		return m.Nics
	}
	return nil
}

func (m *KVM) GetRunLevel() KVM_RunLevel {
	if m != nil {
		return m.RunLevel
	}
	return KVM_SHUTDOWN
}

func (m *KVM) GetVncPort() int32 {
	if m != nil {
		return m.VncPort
	}
	return 0
}

func (m *KVM) GetQmpPath() string {
	if m != nil {
		return m.QmpPath
	}
	return ""
}

// Storage
// definition(label, url)
type KVM_Storage struct {
	Url       string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	BootIndex int32  `protobuf:"varint,2,opt,name=boot_index,json=bootIndex" json:"boot_index,omitempty"`
}

func (m *KVM_Storage) Reset()                    { *m = KVM_Storage{} }
func (m *KVM_Storage) String() string            { return proto.CompactTextString(m) }
func (*KVM_Storage) ProtoMessage()               {}
func (*KVM_Storage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *KVM_Storage) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *KVM_Storage) GetBootIndex() int32 {
	if m != nil {
		return m.BootIndex
	}
	return 0
}

// Network
// definition(tap_name, hwaddr)
type KVM_NIC struct {
	TapName string `protobuf:"bytes,1,opt,name=tap_name,json=tapName" json:"tap_name,omitempty"`
	HwAddr  string `protobuf:"bytes,2,opt,name=hw_addr,json=hwAddr" json:"hw_addr,omitempty"`
}

func (m *KVM_NIC) Reset()                    { *m = KVM_NIC{} }
func (m *KVM_NIC) String() string            { return proto.CompactTextString(m) }
func (*KVM_NIC) ProtoMessage()               {}
func (*KVM_NIC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 2} }

func (m *KVM_NIC) GetTapName() string {
	if m != nil {
		return m.TapName
	}
	return ""
}

func (m *KVM_NIC) GetHwAddr() string {
	if m != nil {
		return m.HwAddr
	}
	return ""
}

type ApplyKVMRequest struct {
	Kvm *KVM `protobuf:"bytes,1,opt,name=kvm" json:"kvm,omitempty"`
}

func (m *ApplyKVMRequest) Reset()                    { *m = ApplyKVMRequest{} }
func (m *ApplyKVMRequest) String() string            { return proto.CompactTextString(m) }
func (*ApplyKVMRequest) ProtoMessage()               {}
func (*ApplyKVMRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ApplyKVMRequest) GetKvm() *KVM {
	if m != nil {
		return m.Kvm
	}
	return nil
}

type DeleteKVMRequest struct {
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DeleteKVMRequest) Reset()                    { *m = DeleteKVMRequest{} }
func (m *DeleteKVMRequest) String() string            { return proto.CompactTextString(m) }
func (*DeleteKVMRequest) ProtoMessage()               {}
func (*DeleteKVMRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DeleteKVMRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ActionKVMRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	QmpPath string `protobuf:"bytes,9,opt,name=qmp_path,json=qmpPath" json:"qmp_path,omitempty"`
}

func (m *ActionKVMRequest) Reset()                    { *m = ActionKVMRequest{} }
func (m *ActionKVMRequest) String() string            { return proto.CompactTextString(m) }
func (*ActionKVMRequest) ProtoMessage()               {}
func (*ActionKVMRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ActionKVMRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ActionKVMRequest) GetQmpPath() string {
	if m != nil {
		return m.QmpPath
	}
	return ""
}

func init() {
	proto.RegisterType((*KVM)(nil), "n0stack.n0core.kvm.KVM")
	proto.RegisterType((*KVM_Storage)(nil), "n0stack.n0core.kvm.KVM.Storage")
	proto.RegisterType((*KVM_NIC)(nil), "n0stack.n0core.kvm.KVM.NIC")
	proto.RegisterType((*ApplyKVMRequest)(nil), "n0stack.n0core.kvm.ApplyKVMRequest")
	proto.RegisterType((*DeleteKVMRequest)(nil), "n0stack.n0core.kvm.DeleteKVMRequest")
	proto.RegisterType((*ActionKVMRequest)(nil), "n0stack.n0core.kvm.ActionKVMRequest")
	proto.RegisterEnum("n0stack.n0core.kvm.KVM_RunLevel", KVM_RunLevel_name, KVM_RunLevel_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for KVMService service

type KVMServiceClient interface {
	ApplyKVM(ctx context.Context, in *ApplyKVMRequest, opts ...grpc.CallOption) (*KVM, error)
	DeleteKVM(ctx context.Context, in *DeleteKVMRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error)
	// VM actions
	Boot(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error)
	Reboot(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error)
	HardReboot(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error)
	Shutdown(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error)
	HardShutdown(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error)
	Save(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error)
}

type kVMServiceClient struct {
	cc *grpc.ClientConn
}

func NewKVMServiceClient(cc *grpc.ClientConn) KVMServiceClient {
	return &kVMServiceClient{cc}
}

func (c *kVMServiceClient) ApplyKVM(ctx context.Context, in *ApplyKVMRequest, opts ...grpc.CallOption) (*KVM, error) {
	out := new(KVM)
	err := grpc.Invoke(ctx, "/n0stack.n0core.kvm.KVMService/ApplyKVM", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVMServiceClient) DeleteKVM(ctx context.Context, in *DeleteKVMRequest, opts ...grpc.CallOption) (*google_protobuf.Empty, error) {
	out := new(google_protobuf.Empty)
	err := grpc.Invoke(ctx, "/n0stack.n0core.kvm.KVMService/DeleteKVM", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVMServiceClient) Boot(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error) {
	out := new(KVM)
	err := grpc.Invoke(ctx, "/n0stack.n0core.kvm.KVMService/Boot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVMServiceClient) Reboot(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error) {
	out := new(KVM)
	err := grpc.Invoke(ctx, "/n0stack.n0core.kvm.KVMService/Reboot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVMServiceClient) HardReboot(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error) {
	out := new(KVM)
	err := grpc.Invoke(ctx, "/n0stack.n0core.kvm.KVMService/HardReboot", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVMServiceClient) Shutdown(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error) {
	out := new(KVM)
	err := grpc.Invoke(ctx, "/n0stack.n0core.kvm.KVMService/Shutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVMServiceClient) HardShutdown(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error) {
	out := new(KVM)
	err := grpc.Invoke(ctx, "/n0stack.n0core.kvm.KVMService/HardShutdown", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *kVMServiceClient) Save(ctx context.Context, in *ActionKVMRequest, opts ...grpc.CallOption) (*KVM, error) {
	out := new(KVM)
	err := grpc.Invoke(ctx, "/n0stack.n0core.kvm.KVMService/Save", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for KVMService service

type KVMServiceServer interface {
	ApplyKVM(context.Context, *ApplyKVMRequest) (*KVM, error)
	DeleteKVM(context.Context, *DeleteKVMRequest) (*google_protobuf.Empty, error)
	// VM actions
	Boot(context.Context, *ActionKVMRequest) (*KVM, error)
	Reboot(context.Context, *ActionKVMRequest) (*KVM, error)
	HardReboot(context.Context, *ActionKVMRequest) (*KVM, error)
	Shutdown(context.Context, *ActionKVMRequest) (*KVM, error)
	HardShutdown(context.Context, *ActionKVMRequest) (*KVM, error)
	Save(context.Context, *ActionKVMRequest) (*KVM, error)
}

func RegisterKVMServiceServer(s *grpc.Server, srv KVMServiceServer) {
	s.RegisterService(&_KVMService_serviceDesc, srv)
}

func _KVMService_ApplyKVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyKVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVMServiceServer).ApplyKVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/n0stack.n0core.kvm.KVMService/ApplyKVM",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVMServiceServer).ApplyKVM(ctx, req.(*ApplyKVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVMService_DeleteKVM_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteKVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVMServiceServer).DeleteKVM(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/n0stack.n0core.kvm.KVMService/DeleteKVM",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVMServiceServer).DeleteKVM(ctx, req.(*DeleteKVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVMService_Boot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionKVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVMServiceServer).Boot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/n0stack.n0core.kvm.KVMService/Boot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVMServiceServer).Boot(ctx, req.(*ActionKVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVMService_Reboot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionKVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVMServiceServer).Reboot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/n0stack.n0core.kvm.KVMService/Reboot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVMServiceServer).Reboot(ctx, req.(*ActionKVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVMService_HardReboot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionKVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVMServiceServer).HardReboot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/n0stack.n0core.kvm.KVMService/HardReboot",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVMServiceServer).HardReboot(ctx, req.(*ActionKVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVMService_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionKVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVMServiceServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/n0stack.n0core.kvm.KVMService/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVMServiceServer).Shutdown(ctx, req.(*ActionKVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVMService_HardShutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionKVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVMServiceServer).HardShutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/n0stack.n0core.kvm.KVMService/HardShutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVMServiceServer).HardShutdown(ctx, req.(*ActionKVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _KVMService_Save_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionKVMRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(KVMServiceServer).Save(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/n0stack.n0core.kvm.KVMService/Save",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(KVMServiceServer).Save(ctx, req.(*ActionKVMRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _KVMService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "n0stack.n0core.kvm.KVMService",
	HandlerType: (*KVMServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ApplyKVM",
			Handler:    _KVMService_ApplyKVM_Handler,
		},
		{
			MethodName: "DeleteKVM",
			Handler:    _KVMService_DeleteKVM_Handler,
		},
		{
			MethodName: "Boot",
			Handler:    _KVMService_Boot_Handler,
		},
		{
			MethodName: "Reboot",
			Handler:    _KVMService_Reboot_Handler,
		},
		{
			MethodName: "HardReboot",
			Handler:    _KVMService_HardReboot_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _KVMService_Shutdown_Handler,
		},
		{
			MethodName: "HardShutdown",
			Handler:    _KVMService_HardShutdown_Handler,
		},
		{
			MethodName: "Save",
			Handler:    _KVMService_Save_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/kvm/kvm.proto",
}

func init() { proto.RegisterFile("proto/kvm/kvm.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 690 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0xd3, 0x4c,
	0x10, 0xad, 0x9b, 0x1f, 0x3b, 0x93, 0x7c, 0x1f, 0xd1, 0x22, 0x51, 0x93, 0x0a, 0x91, 0x06, 0x84,
	0xc2, 0x8d, 0xdd, 0x06, 0x55, 0x82, 0x0a, 0x90, 0xd2, 0x1f, 0xb5, 0x21, 0xc4, 0xad, 0x9c, 0x36,
	0x48, 0x70, 0x61, 0x39, 0xf6, 0x92, 0x58, 0xb1, 0x77, 0xdd, 0xf5, 0xda, 0xc5, 0x2f, 0xc6, 0x6b,
	0xf1, 0x0a, 0x68, 0xed, 0xa4, 0x94, 0x92, 0xf4, 0xa6, 0xbd, 0x88, 0x34, 0x3b, 0x39, 0x73, 0x72,
	0xe6, 0xcc, 0x64, 0x17, 0x1e, 0x87, 0x8c, 0x72, 0xaa, 0xcf, 0x92, 0x40, 0x7c, 0xb4, 0xec, 0x84,
	0x10, 0xd9, 0x8e, 0xb8, 0xed, 0xcc, 0x34, 0xb2, 0xed, 0x50, 0x86, 0xb5, 0x59, 0x12, 0x34, 0x36,
	0x27, 0x94, 0x4e, 0x7c, 0xac, 0x67, 0x88, 0x71, 0xfc, 0x5d, 0xc7, 0x41, 0xc8, 0xd3, 0xbc, 0xa0,
	0xf5, 0xb3, 0x04, 0x85, 0xfe, 0x68, 0x80, 0x10, 0x14, 0xe3, 0xd8, 0x73, 0x55, 0xa9, 0x29, 0xb5,
	0x2b, 0x66, 0x16, 0x8b, 0x1c, 0xb1, 0x03, 0xac, 0xae, 0xe7, 0x39, 0x11, 0xa3, 0x4d, 0xa8, 0x38,
	0x61, 0x6c, 0x09, 0xf2, 0x48, 0x2d, 0x34, 0xa5, 0xf6, 0x7f, 0xa6, 0xe2, 0x84, 0xf1, 0x81, 0x38,
	0xa3, 0x2d, 0xa8, 0x05, 0x38, 0xa0, 0x2c, 0xb5, 0xc6, 0x29, 0xc7, 0x91, 0x5a, 0x6c, 0x4a, 0xed,
	0xa2, 0x59, 0xcd, 0x73, 0xfb, 0x22, 0x85, 0x3e, 0x82, 0x9c, 0x50, 0x3f, 0x0e, 0x70, 0xa4, 0x96,
	0x9a, 0x85, 0x76, 0xb5, 0xf3, 0x52, 0xfb, 0x57, 0xb2, 0xd6, 0x1f, 0x0d, 0xb4, 0x51, 0x0e, 0x3b,
	0x22, 0x9c, 0xa5, 0xe6, 0xa2, 0x08, 0xed, 0x42, 0x91, 0x78, 0x4e, 0xa4, 0x96, 0xb3, 0xe2, 0xad,
	0x55, 0xc5, 0x86, 0xe7, 0xcc, 0x2b, 0x33, 0x38, 0xfa, 0x00, 0x15, 0x16, 0x13, 0xcb, 0xc7, 0x09,
	0xf6, 0x55, 0xb9, 0x29, 0xb5, 0xff, 0xef, 0x34, 0x57, 0xd5, 0x9a, 0x31, 0xf9, 0x2c, 0x70, 0xa6,
	0xc2, 0xe6, 0x11, 0x7a, 0x0a, 0x4a, 0x42, 0x1c, 0x2b, 0xa4, 0x8c, 0xab, 0x4a, 0x53, 0x6a, 0x97,
	0x4c, 0x39, 0x21, 0xce, 0x19, 0x65, 0x5c, 0x7c, 0x75, 0x19, 0x84, 0x56, 0x68, 0xf3, 0xa9, 0x5a,
	0xc9, 0x8c, 0x92, 0x2f, 0x83, 0xf0, 0xcc, 0xe6, 0xd3, 0xc6, 0x1e, 0xc8, 0x43, 0x4e, 0x99, 0x3d,
	0xc1, 0xa8, 0x0e, 0x85, 0x98, 0xf9, 0x73, 0x77, 0x45, 0x88, 0x9e, 0x01, 0x8c, 0x29, 0xe5, 0x96,
	0x47, 0x5c, 0xfc, 0x23, 0xb3, 0xb8, 0x64, 0x56, 0x44, 0xa6, 0x27, 0x12, 0x8d, 0x6f, 0x50, 0xbb,
	0x69, 0x80, 0x20, 0x98, 0xe1, 0x74, 0x41, 0x30, 0xc3, 0x29, 0xda, 0x85, 0x52, 0x62, 0xfb, 0x71,
	0x3e, 0x9e, 0x6a, 0xe7, 0xf9, 0xaa, 0x76, 0xe6, 0x12, 0xcc, 0x1c, 0xbd, 0xb7, 0xfe, 0x56, 0x6a,
	0xbc, 0x83, 0x82, 0xd1, 0x3b, 0x10, 0xd2, 0xb9, 0x1d, 0x5a, 0xd9, 0x8c, 0x73, 0x62, 0x99, 0xdb,
	0xa1, 0x21, 0xc6, 0xbc, 0x01, 0xf2, 0xf4, 0xca, 0xb2, 0x5d, 0x97, 0xcd, 0xa7, 0x5f, 0x9e, 0x5e,
	0x75, 0x5d, 0x97, 0x35, 0xce, 0xa1, 0x72, 0xed, 0xed, 0x12, 0x51, 0x3b, 0x7f, 0x8b, 0xda, 0x5c,
	0x39, 0x9f, 0xde, 0xc1, 0x0d, 0x41, 0xad, 0x1d, 0x50, 0x16, 0xae, 0xa3, 0x1a, 0x28, 0xc3, 0x93,
	0x8b, 0xf3, 0xc3, 0xd3, 0x2f, 0x46, 0x7d, 0x0d, 0x55, 0x41, 0x36, 0x2f, 0x0c, 0xa3, 0x67, 0x1c,
	0xd7, 0x25, 0x04, 0x50, 0x3e, 0xeb, 0x5e, 0x0c, 0x8f, 0x0e, 0xeb, 0xeb, 0xad, 0xf7, 0xf0, 0xa8,
	0x1b, 0x86, 0x7e, 0xda, 0x1f, 0x0d, 0x4c, 0x7c, 0x19, 0xe3, 0x88, 0xa3, 0xd7, 0x50, 0x98, 0x25,
	0x41, 0x26, 0xa7, 0xda, 0xd9, 0x58, 0xf1, 0xd3, 0xa6, 0xc0, 0xb4, 0x5e, 0x41, 0xfd, 0x10, 0xfb,
	0x98, 0xe3, 0x1b, 0xe5, 0x8b, 0x75, 0x97, 0xfe, 0xac, 0x7b, 0xab, 0x0b, 0xf5, 0xae, 0xc3, 0x3d,
	0x4a, 0xee, 0xc6, 0xdd, 0xb1, 0x05, 0x9d, 0x5f, 0x45, 0x80, 0xfe, 0x68, 0x30, 0xc4, 0x2c, 0xf1,
	0x1c, 0x8c, 0x3e, 0x81, 0xb2, 0xd0, 0x8d, 0x5e, 0x2c, 0xd3, 0x78, 0xab, 0xab, 0xc6, 0xaa, 0x46,
	0x5a, 0x6b, 0xa8, 0x0f, 0x95, 0xeb, 0x2e, 0xd0, 0xd2, 0x3f, 0xd2, 0xed, 0x26, 0x1b, 0x4f, 0xb4,
	0xfc, 0x36, 0xd0, 0x16, 0xb7, 0x81, 0x76, 0x24, 0x6e, 0x83, 0xd6, 0x1a, 0x3a, 0x86, 0xe2, 0x3e,
	0xa5, 0x7c, 0x39, 0xcf, 0x6d, 0x13, 0xee, 0x52, 0xd5, 0x83, 0xb2, 0x89, 0xc7, 0x0f, 0x42, 0x35,
	0x00, 0x38, 0xb1, 0x99, 0xfb, 0x50, 0x74, 0x7d, 0x50, 0x86, 0xd3, 0x98, 0xbb, 0xf4, 0x8a, 0xdc,
	0x9f, 0xec, 0x14, 0x6a, 0x42, 0xdb, 0xc3, 0x11, 0x1e, 0x43, 0x71, 0x68, 0x27, 0xf8, 0xde, 0x44,
	0xfb, 0x3b, 0x5f, 0xf5, 0x89, 0xc7, 0xa7, 0xf1, 0x58, 0x73, 0x68, 0xa0, 0xcf, 0x61, 0x7a, 0x0e,
	0x13, 0xaf, 0x40, 0xe2, 0x45, 0x1e, 0x25, 0x1e, 0x99, 0xe8, 0x84, 0xba, 0x58, 0xbc, 0x1e, 0xe3,
	0x72, 0xb6, 0x0e, 0x6f, 0x7e, 0x07, 0x00, 0x00, 0xff, 0xff, 0xf9, 0xf9, 0x89, 0xb6, 0x55, 0x06,
	0x00, 0x00,
}
