// Code generated by "standard_api"; DO NOT EDIT.

package avirtualmachine

import (
	"context"

	"github.com/golang/protobuf/proto"
	"n0st.ac/n0stack/n0core/pkg/datastore"
	grpcutil "n0st.ac/n0stack/n0core/pkg/util/grpc"
	pinfrastructure "n0st.ac/n0stack/n0proto.go/infrastructure/v0"
	"n0st.ac/n0stack/n0proto.go/pkg/transaction"
	"google.golang.org/grpc/codes"
)

func ListVirtualMachines(ctx context.Context, req *pinfrastructure.ListVirtualMachinesRequest, ds datastore.Datastore) (*pinfrastructure.ListVirtualMachinesResponse, error) {
	res := &pinfrastructure.ListVirtualMachinesResponse{}
	f := func(s int) []proto.Message {
		res.VirtualMachines = make([]*pinfrastructure.VirtualMachine, s)
		for i := range res.VirtualMachines {
			res.VirtualMachines[i] = &pinfrastructure.VirtualMachine{}
		}

		m := make([]proto.Message, s)
		for i, v := range res.VirtualMachines {
			m[i] = v
		}

		return m
	}

	if err := ds.List(f); err != nil {
		return nil, grpcutil.Errorf(codes.Internal, "Failed to list from db, please retry or contact for the administrator of this cluster")
	}
	if len(res.VirtualMachines) == 0 {
		return nil, grpcutil.Errorf(codes.NotFound, "")
	}

	return res, nil
}

func GetVirtualMachine(ctx context.Context, req *pinfrastructure.GetVirtualMachineRequest, ds datastore.Datastore) (*pinfrastructure.VirtualMachine, error) {
	resourse := &pinfrastructure.VirtualMachine{}
	if err := ds.Get(req.Name, resourse); err != nil {
		if datastore.IsNotFound(err) {
			return nil, grpcutil.Errorf(codes.NotFound, err.Error())
		}

		return nil, grpcutil.Errorf(codes.Internal, datastore.DefaultErrorMessage(err))
	}

	return resourse, nil
}

func GetAndPendExistingVirtualMachine(tx *transaction.Transaction, ds datastore.Datastore, name string) (*pinfrastructure.VirtualMachine, error) {
	resource := &pinfrastructure.VirtualMachine{}
	if err := ds.Get(name, resource); err != nil {
		if datastore.IsNotFound(err) {
			return nil, grpcutil.Errorf(codes.NotFound, err.Error())
		}

		return nil, grpcutil.Errorf(codes.Internal, datastore.DefaultErrorMessage(err))
	}

	if resource.State == pinfrastructure.VirtualMachine_PENDING {
		return nil, grpcutil.Errorf(codes.FailedPrecondition, "VirtualMachine %s is pending", name)
	}

	current := resource.State
	resource.State = pinfrastructure.VirtualMachine_PENDING
	if err := ApplyVirtualMachine(ds, resource); err != nil {
		return nil, err
	}
	resource.State = current
	tx.PushRollback("free optimistic lock", func() error {
		resource.State = current
		return ds.Apply(resource.Name, resource)
	})

	return resource, nil
}

func PendNewVirtualMachine(tx *transaction.Transaction, ds datastore.Datastore, name string) error {
	resource := &pinfrastructure.VirtualMachine{}
	if err := ds.Get(name, resource); err == nil {
		return grpcutil.Errorf(codes.AlreadyExists, "VirtualMachine %s is already exists", name)
	} else if !datastore.IsNotFound(err) {
		return grpcutil.Errorf(codes.Internal, datastore.DefaultErrorMessage(err))
	}

	resource.Name = name
	resource.State = pinfrastructure.VirtualMachine_PENDING
	if err := ApplyVirtualMachine(ds, resource); err != nil {
		return err
	}
	tx.PushRollback("free optimistic lock", func() error {
		return ds.Delete(name)
	})

	return nil
}

func DeleteVirtualMachine(ds datastore.Datastore, name string) error {
	if err := ds.Delete(name); err != nil {
		return grpcutil.Errorf(codes.Internal, "failed to delete VirtualMachine %s from db: err='%s'", name, err.Error())
	}

	return nil
}

func ApplyVirtualMachine(ds datastore.Datastore, resource *pinfrastructure.VirtualMachine) error {
	if err := ds.Apply(resource.Name, resource); err != nil {
		return grpcutil.Errorf(codes.Internal, "failed to apply VirtualMachine %s to db: err='%s'", resource.Name, err.Error())
	}

	return nil
}
